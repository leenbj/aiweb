import type { Response } from 'express';
import { randomUUID } from 'crypto';

export interface StreamEmitterOptions {
  requestId?: string;
  pingIntervalMs?: number;
  includeTimestamp?: boolean;
}

export type StageStatus = 'start' | 'success' | 'error';

export class StreamEmitter {
  private closed = false;
  private readonly requestId: string;
  private pingTimer: NodeJS.Timeout | null = null;

  constructor(private res: Response, private options: StreamEmitterOptions = {}) {
    this.requestId = options.requestId || randomUUID();
    res.setHeader('Content-Type', 'text/event-stream');
    res.setHeader('Cache-Control', 'no-cache, no-transform');
    res.setHeader('Connection', 'keep-alive');
    res.setHeader('X-Request-Id', this.requestId);

    // flush headers immediately (if supported)
    if (typeof (res as any).flushHeaders === 'function') {
      (res as any).flushHeaders();
    } else {
      res.write('');
    }

    this.schema();
    const interval = options.pingIntervalMs ?? 15000;
    this.pingTimer = setInterval(() => {
      if (!this.closed) {
        this.res.write(': ping\n\n');
      }
    }, interval);
  }

  schema(): void {
    this.send('schema', {
      requestId: this.requestId,
      version: '2025-09-17',
      events: {
        schema: 'Stream metadata with supported event types and request id.',
        stage: 'High-level pipeline status updates (start/success/error).',
        plan: 'Template plan details generated by TemplatePlanner.',
        preview: 'Previewable HTML output along with component renders.',
        log: 'Diagnostic information or warnings emitted during processing.',
        complete: 'Final payload including snapshot metadata.',
        error: 'Terminal error describing why the stream aborted.',
      },
    });
  }

  stage(stage: string, status: StageStatus, data?: Record<string, any>): void {
    this.send('stage', { stage, status, ...data });
  }

  plan(payload: { plan: any; metadata?: Record<string, any> }): void {
    this.send('plan', payload);
  }

  preview(payload: { html: string; components: Array<{ slug: string; html: string }>; metadata?: Record<string, any> }): void {
    this.send('preview', payload);
  }

  log(level: 'info' | 'warn' | 'debug', message: string, data?: Record<string, any>): void {
    this.send('log', { level, message, ...data });
  }

  complete(payload: Record<string, any>): void {
    this.send('complete', payload);
    this.close();
  }

  error(message: string, data?: Record<string, any>): void {
    this.send('error', { message, ...data });
    this.close();
  }

  close(): void {
    if (this.closed) return;
    this.closed = true;
    if (this.pingTimer) {
      clearInterval(this.pingTimer);
      this.pingTimer = null;
    }
    this.res.end();
  }

  send(type: string, payload: Record<string, any>): void {
    if (this.closed) return;
    const enriched = {
      type,
      requestId: this.requestId,
      timestamp: this.options.includeTimestamp !== false ? new Date().toISOString() : undefined,
      ...payload,
    };
    this.res.write(`data: ${JSON.stringify(enriched)}\n\n`);
  }
}

export function createStreamEmitter(res: Response, options: StreamEmitterOptions = {}) {
  return new StreamEmitter(res, options);
}
